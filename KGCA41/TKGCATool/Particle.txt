struct VS_IN
{
	float3 p : POSITION; 
	float3 n : NORMAL; 
    float4 c : COLOR;
	float2 t : TEXTURE;
};
struct VS_OUT
{
	float4 p : SV_POSITION;
	float3 n : NORMAL;
	float4 c : COLOR0;
	float2 t : TEXCOORD0;
};
// 상수버퍼는 레지스터 단위로만 저장된다.
// 레지스터 단위란 :  float4(x,y,z,w)
cbuffer cb_data : register(b0)
{
	matrix g_matWorld : packoffset(c0);
	matrix g_matView : packoffset(c4);
	matrix g_matProj : packoffset(c8);
	float4 vTimer : packoffset(c12);
};
VS_OUT VS_Default(VS_IN input) 
{
	VS_OUT output = (VS_OUT)0;
	float4 vLocal = float4(input.p,1.0f);
	float4 vWorld = mul(vLocal, g_matWorld);
	float4 vView = mul(vWorld, g_matView);
	float4 vProj = mul(vView, g_matProj);	
	output.p = vProj;
	output.n = input.n;
	output.c = input.c;
	output.t = input.t;
	return output;
}
VS_OUT VS(VS_IN input) 
{
	VS_OUT output = (VS_OUT)0;
	output.p = float4(input.p.xyz, 1.0f);	
	output.c = input.c;

	output.n = input.n;
	output.t = input.t;
	return output;
}
struct G_OUT
{
	float4 p : SV_POSITION;
	float3 n : NORMAL;
	float4 c : COLOR0;
	float2 t : TEXCOORD0;
};

[maxvertexcount(4)]
void GS(in point VS_OUT vIn[1], inout TriangleStream<G_OUT> vOut)
{
	// Strip으로 구성한다.
	const float3 g_positions[4] =
	{
		float3(-1.0,  1.0, 0.0),
		float3(1.0,  1.0, 0.0),
		float3(-1.0, -1.0, 0.0),
		float3(1.0, -1.0, 0.0),
	};
	/*float4 g_color[4] =
	{
		float4(1.0f, 0.0f, 0.2f, 1.0f),
		float4(0.0f,1.0f, 0.0f, 1.0f),
		float4(0.0f, 0.0f, 1.0f,1.0f),
		float4(1.0f, 1.0f,1.0f,  1.0f),
	};*/
	const float2 g_texcoords[4] =
	{
		float2(0.0, 0.0),
		float2(1.0, 0.0),
		float2(0.0, 1.0),
		float2(1.0, 1.0),
	};

	G_OUT vVertex;
	for (int i = 0; i < 4; i++)
	{
		vVertex.p = float4(vIn[0].p.xyz + g_positions[i].xyz, 1.0f);
		vVertex.c = vIn[0].c;
		vVertex.t = g_texcoords[i];
		vVertex.n = vIn[0].n;

		float4 vWorld = mul(vVertex.p, g_matWorld);
		float4 vView  = mul(vWorld, g_matView);
		vVertex.p	  = mul(vView, g_matProj);

		vOut.Append(vVertex);
	}
	vOut.RestartStrip();
}

Texture2D    g_txTex			: register(t0);
SamplerState g_SampleWrap		: register(s0);

struct PS_OUT
{
	float4 a : SV_TARGET0; // +
	float4 b : SV_TARGET1; // *
};

PS_OUT PS(VS_OUT input) : SV_Target
{
	PS_OUT vOut;
	float4 vColor = g_txTex.Sample(g_SampleWrap , input.t);
	float alpha = max(max(vColor.r, vColor.g), vColor.b);
	vOut.b = float4(1.0f- alpha, 
					1.0f- alpha,
					1.0f- alpha,1.0f);
	vOut.a = vColor*input.c;
	return vOut;	
}

float4 PSColor(VS_OUT input) : SV_Target
{
	return input.c;
}