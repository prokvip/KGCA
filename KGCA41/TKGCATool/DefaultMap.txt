#include "Default.h"
struct VS_IN
{
	float3 p : POSITION; 
	float3 n : NORMAL; 
    float4 c : COLOR;
	float2 t : TEXTURE;
};
struct VS_OUT
{
	float4 p : SV_POSITION;
	float3 n : NORMAL; 
	float4 c : COLOR0;
	float4 t : TEXCOORD0;
	float3 L : TEXCOORD1;
	float3 w : TEXCOORD2;//world
};

VS_OUT VS(VS_IN input) 
{
#ifdef EXAMPLE_DEFINE
#endif
	VS_OUT output = (VS_OUT)0;
	float4 vLocal = float4(input.p,1.0f);
	// 중요:  mul 함수는 내적으로 처리된다.
	// vWolrd.x = vLocal dot c0; // 행*행
	// vWolrd.y = vLocal dot c1;
	// vWolrd.z = vLocal dot c2;
	// vWolrd.w = vLocal dot c3;	
	matrix matNormal = transpose(g_matWorldInverse);
	float4 vWorld = mul(vLocal, g_matWorld);
	float4 vView = mul(vWorld, g_matView);
	float4 vProj = mul(vView, g_matProj);	
	output.p = vProj;
	output.c = input.c;
	//output.t = input.t;
	// 0 ~ 65, cellDistange = 1.0f, tileCnt = 10.0f
	//float xMin = 32*1.0f;
	//float xMax = +32*1.0f;
	// 월드 좌표를 기준으로 텍스처 좌표 생성
	output.t.x = (vWorld.x+ 32.0f*1.0f) / 65.0f; // 0 ~1
	output.t.y = 1.0f-((vWorld.z / 32.0f*1.0f)* 0.5f+0.5f);//0~1	
	output.t.x = output.t.x*10.0f;
	output.t.y = output.t.y*10.0f;

	// 텍스처 변환 행렬 사용
	matrix matTex=0;
	matTex._11 = 1.0f / ((65.0f/10.0f)*1.0f);
	matTex._32 = -1.0f / ((65.0f/10.0f)*1.0f);
	matTex._41 = 0.0f; // 타일에 개수 홀수=0.5f, 짝수=-0.0f
	matTex._42 = 0.0f;

	float4 vUV = mul(vWorld, matTex);
	output.t.x = vUV.x;
	output.t.y = vUV.y;

	// 투영좌표 사용
	output.t.z = (vProj.x / vProj.w)*0.5f+0.5f;
	output.t.w = (vProj.y / vProj.w)*0.5f+0.5f;


	output.w = vWorld.xyz;
	output.n = mul(input.n.xyz, matNormal);
	return output;
}
float4 LoadTex1Color(float2 uv, float3 vWorld) 
{
	float4 vColor = 0;
	if(vWorld.y <= 8.0f)
	{
		float4 vColorA = g_txTex1.Sample(g_SampleWrap , uv);	
		float4 vColorB = g_txTex2.Sample(g_SampleWrap , uv);
		float t = smoothstep(2.0f, 4.0f, vWorld.y);
		vColor = lerp( vColorA, vColorB,t);
	}
	return vColor;
}
float4 LoadTex2Color(float2 uv, float3 vWorld) 
{
	float4 vColor = 0;
	if(vWorld.y > 8.0f && vWorld.y <= 13.0f)
	{
		float4 vColorA = g_txTex2.Sample(g_SampleWrap , uv);	
		float4 vColorB = g_txTex3.Sample(g_SampleWrap , uv);
		float t = smoothstep(8.0f, 10.0f, vWorld.y);
		vColor = lerp( vColorA, vColorB,t);	
	}
	return vColor;
}
float4 LoadTex3Color(float2 uv, float3 vWorld) 
{
	float4 vColor = 0;
	if(vWorld.y > 13.0f && vWorld.y <= 18.0f)
	{
		float4 vColorA = g_txTex3.Sample(g_SampleWrap , uv);	
		float4 vColorB = g_txTex4.Sample(g_SampleWrap , uv);
		float t = smoothstep(13.0f, 15.0f, vWorld.y);
		vColor = lerp( vColorA, vColorB,t);	
	}
	return vColor;
}
float4 LoadTex4Color(float2 uv, float3 vWorld) 
{
	float4 vColor = 0;
	if(vWorld.y > 18.0f && vWorld.y <= 25.0f)
	{
		float4 vColorA = g_txTex4.Sample(g_SampleWrap , uv);	
		float4 vColorB = g_txTex5.Sample(g_SampleWrap , uv);
		float t = smoothstep(18.0f, 20.0f, vWorld.y);
		vColor = lerp( vColorA, vColorB,t);	
	}
	return vColor;
}
float4 LoadTex5Color(float2 uv, float3 vWorld) 
{
	float4 vColor = 0;
	if(vWorld.y > 25.0f)
	{
		vColor = g_txTex5.Sample(g_SampleWrap , uv);					
	}
	return vColor;
}
float4 PS(VS_OUT input) : SV_Target
{
	float4 vColor = LoadTex1Color(input.t.xy,input.w);	
	vColor += LoadTex2Color(input.t.xy,input.w);	
	vColor += LoadTex3Color(input.t.xy,input.w);	
	vColor += LoadTex4Color(input.t.xy,input.w);	
	vColor += LoadTex5Color(input.t.xy,input.w);	

	float4 vBaseColor = g_txTex.Sample(g_SampleWrap , input.t.xy);	
	float4 vLightColor = 
						ComputePointDiffuseLight(input.w, input.n, 1)
						+ComputeSpotDiffuseLight(input.w, input.n, 1)
						+ComputePointSpecularLight(input.w, input.n, 1)
						+ComputeSpotSpecularLight(input.w, input.n, 1);
	float4 fFinalColor = vColor*vBaseColor*vLightColor;
	fFinalColor.a = 1.0f;
	return fFinalColor;	
}

float4 PSColor(VS_OUT input) : SV_Target
{
	return input.c;
}