오브젝트풀

** 마스크값 사용(제한된 범위에서 재사용 가능해 진다. 원형 큐 적용되어)

#define POOL_MAX_SIE 8
#eefine POOL_SIZE_MASK (POOL_MAX_SIE-1)
new Object[POOL_MAX_SIE] = {nullptr,};
int g_iHead=0; // 생성 및 할당 인덱스
int g_iTail=0; // 소멸 및 해제 인덱스
// 준비되어 있으면 준비된 오브젝트를 반환해주고
// 준비된 오브젝트가 없으면 신규로 생성해서 반환해주자.
Object*  new()
{
	int iCurrent = g_iHead++;
	int iPos = iCurrent & POOL_SIZE_MASK;
	Object* pObj = Object[iPos];
	Object[iPos]= nullptr;
	if( pObj != nullptr) return pObj;
	return new Object;
}
void  delete(Object* deleteObj)
{
	int iCurrent = g_iTail++;
	int iPos = iCurrent & POOL_SIZE_MASK;
	Object* pObj = Object[iPos];
	Object[iPos]= deleteObj;// 재사용
	if( pObj != nullptr) delete pObj;	
}
Object* obj = new Object;
delete obj;

1->0(g_iHead) & 7 ==> 0000 & 0111 --> 0
2->1 & 7 ==> 0001 & 0111 --> 1
3->2 & 7 ==> 0010 & 0111 --> 2
4->3 & 7 ==> 0011 & 0111 --> 3
5->4 & 7 ==> 0100 & 0111 --> 4
6->5 & 7 ==> 0101 & 0111 --> 5
7->6 & 7 ==> 0110 & 0111 --> 6
8->7 & 7 ==> 0111 & 0111 --> 7

9->8 & 7 ==> 1000 & 0111 --> 0


1)배열을 사용해서 구현한다.
2)사전에 오브젝트를 임의의 개수만큼 할당해 
  놓고나 아니거나 사용 가능해야 한다.
3)무한대의 할당이 있어야 한다. 
4)삭제 시는 배열 범위에서 재사용하고 범위 밖은 삭제한다.

5)메모리 단편화 방지 효과가 있어야 한다.
6)사용상 편리(재사용, 확장성)를 제공, 관리(메니저)가 추상적으로 구현되어 있어야 한다.
7)스레드에서 안전하게 사용해야 한다.